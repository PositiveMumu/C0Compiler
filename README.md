# C0Compiler
### 作者：vili &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 联系方式vili_wzl@126.com

*2018年编译原理大作业,基于java语言和JavaCC工具的C0语言编译器*

## 目录

* [1.C0语言介绍](#1)
* [2.项目功能](#2)
* [3.项目介绍](#3)
<h2 id="1">1.C0语言介绍</h2>

C0语言的语法结构定义如下：

<程序>->[<变量定义部分>] {<自定义函数定义部分>} <主函数>

<变量定义部分>-> int id {, id};

<自定义函数定义部分>-> ( int id | void id) '(' ')' <分程序>

<主函数>->void main'(' ')' <分程序>

<分程序>->'{' [<变量定义部分>] <语句序列> '}'  

<语句序列>-><语句> {<语句>}

<语句>-> <条件语句>｜<循环语句> | '{'<语句序列>'}' | <自定义函数调用语句> 
| <赋值语句> | <返回语句> | <读语句> | <写语句> | ;

<条件语句>->if '('<表达式>')' <语句> [else <语句> ]

<循环语句>->while '(' <表达式>')' <语句>

<自定义函数调用语句>-><自定义函数调用>;

<赋值语句>->id = <表达式>;

<返回语句>->return ['(' <表达式> ')'] ;

<读语句>->scanf '(' id ')';

<写语句>->printf '(' [ <表达式>] ')';

<表达式>-> [+｜-] <项> { (+｜-) <项>} 

<项> -> <因子>｛(*｜/) <因子>｝

<因子> -> id｜'(' <表达式>')' | num | <自定义函数调用>

<自定义函数调用>->id '(' ')'

其中，id代表标识符，num代表整数，其含义及构成方式与C语言相一致；C0源程序中的变量需先定义后使用，其作用域与生存期与C语言相一致；自定义函数可超前使用（调用在前，定义在后）；其它方面的语义与C语言相一致。

假想的栈式指令系统表

|指令|含义|
|--|--|
|LIT 0 a|将常数值取到栈顶，a为常数值|
|LOD t a|将变量值取到栈顶，a为相对地址，t为层差|
|STO t a|将栈顶内容送入某变量单元中，a为相对地址，t为层差|
|CAL 0 a|调用函数，a为函数地址|
|INT 0 a|在运行栈中为被调用的过程开辟a个单元的数据区|
|JMP 0 a|无条件跳转至a地址|
|JPC 0 a|条件跳转，当栈顶值为0，则跳转至a地址，否则顺序执行|
|ADD 0 0|次栈顶与栈顶相加，退两个栈元素，结果值进栈|
|SUB 0 0|次栈顶减去栈顶，退两个栈元素，结果值进栈|
|MUL 0 0|次栈顶乘以栈顶，退两个栈元素，结果值进栈|
|DIV 0 0|次栈顶除以栈顶，退两个栈元素，结果值进栈|
|RED 0 0|从命令行读入一个输入置于栈顶|
|WRT 0 0|栈顶值输出至屏幕并换行|
|RET 0 0|函数调用结束后,返回调用点并退栈|

<h2 id="2">2.项目功能</h2>

该编译器可以实现对C0程序的编译及执行过程，用户通过输入源代码所在地址进行编译，在编译过程中，如果发现编译错误将直接停止运行并报告错误（错误类型有两种，一种是封装好的错误类MyError输出的，另外一种是JavaCC输出的错误），并会让用户选择一些输出。用户可以输入目标文件（中间指令文件）的存放路径，并原则是否直接解释执行。用户也可在编译程序运行结束再运行解释执行程序来解释执行刚刚生成的目标文件。

<h2 id="3">3.项目介绍</h2>

1.本项目由解释执行程序（Eexcute）和编译程序（Compiler）两个主要模块构成。编译程序负责将C0源代码编译并生成中间指令序列，解释执行程序负责将指令序列解释执行并生成结果。编译程序由JavaCC工具编译生成。

2.在Compiler包下主要的文件有Compiler.jj,ErrorCode.java,MyError.java,SymbolItem.java。其他文件均由Compiler.jj编译得到，具体方法详见JavaCC官网。

3.测试文件存放在testFile文件夹下。

4.项目使用IDEA 2017.3.5编写，请使用相同软件打开。
